'use strict';

const { getConfigUrls } = require('@strapi/utils');
const tsUtils = require('@strapi/typescript-utils');

const chalk = require('chalk');
const path = require('path');
const fs = require('fs-extra');
const viteReact = require('@vitejs/plugin-react');
const { nodeResolve } = require('@rollup/plugin-node-resolve');
const commonjs = require('@rollup/plugin-commonjs');
const ee = require('../../../utils/ee');
const strapiNodeApp = require('../../../Strapi');
const getEnabledPlugins = require('../../../core/loaders/plugins/get-enabled-plugins');
const { loadPkg } = require('../../utils/pkg');
const { viteBuildTask } = require('../vite/viteBuildTask');
const { decorateHTMLWithAutoGeneratedWarning, getDocumentHTML } = require('./document');
const { getEntryModule } = require('./entry');
const getUserPluginsConfig = require('../../../core/loaders/plugins/get-user-plugins-config');
const { camelCase } = require('lodash/fp');

/**
 * @typedef AdminBuilderArgs
 * @property {"vite" | "webpack"} builder
 * @property {string} distDir
 * @property {string} cwd
 * @property {string | undefined} tsconfig
 */

/**
 * @type {({ builder, distDir, cwd, tsconfig }: AdminBuilderArgs) => Promise<void>}
 */
const buildAdmin = async ({ distDir, cwd, builder, tsconfig }) => {
  const spinner = createSpinner(`Building your admin UI with production configuration...`);

  const strapiInstance = strapiNodeApp({
    // Directories
    appDir: cwd,
    distDir,
    // Options
    autoReload: true,
    serveAdminPanel: false,
  });

  const ctx = await createBuildContext({ cwd, tsconfig, distDir });

  try {
    /**
     * For Vite to work effectively we create a client folder in `.strapi` at the cwd level.
     * We then use the function we need to "createAdmin" as well as generate the Document index.html as well.
     *
     * All this links together an imaginary "src/index" that then allows vite to correctly build the admin panel.
     */

    const runtimeDir = path.join(cwd, '.strapi', 'client');

    await fs.mkdir(runtimeDir, { recursive: true });

    /**
     * TODO: should this list of internal plugins just be
     * imported from `core/loaders/plugins/get-enabled-plugins`?
     */
    /**
     * @type {import('./entry').EntryModuleArgs['plugins']}
     */
    const internalPlugins = [
      {
        path: '@strapi/plugin-content-type-builder/strapi-admin',
        name: 'content-type-builder',
        importName: 'contentTypeBuilder',
      },
      { path: '@strapi/plugin-email/strapi-admin', name: 'email', importName: 'email' },
      { path: '@strapi/plugin-upload/strapi-admin', name: 'upload', importName: 'upload' },
    ];

    const allEnabledPlugins = await getEnabledPlugins(strapiInstance);

    /**
     * To be an actual importable dependency we need to have a `strapi-admin.js` file
     * within the plugin folder, otherwise we don't want to try and use it on the FE.
     *
     * @type {import('./entry').EntryModuleArgs['plugins']}
     */
    const dependencyPlugins = Object.values(allEnabledPlugins)
      .filter(
        (plugin) =>
          typeof plugin.info.packageName === 'string' &&
          fs.existsSync(path.join(plugin.pathToPlugin, 'strapi-admin.js'))
      )
      .map((plugin) => ({
        path: `${plugin.info.packageName}/strapi-admin`,
        name: plugin.info.name,
        importName: camelCase(plugin.info.name),
      }));

    const userPlugins = await getUserPluginsConfig();

    const userPluginsToInstall = Object.entries(userPlugins)
      .filter(([_, config]) => typeof config.resolve === 'string')
      .map(([name, config]) => ({
        path: `${path.relative(runtimeDir, config.resolve)}/strapi-admin`,
        name,
        importName: camelCase(name),
      }));

    const plugins = [...internalPlugins, ...dependencyPlugins, ...userPluginsToInstall];

    // const { serverUrl, adminPath } = getConfigUrls(strapiInstance.config, true);

    ee.init(cwd);

    console.log(builder);

    if (builder === 'vite') {
      const indexHtml = decorateHTMLWithAutoGeneratedWarning(
        getDocumentHTML({
          props: {
            isVite: true,
            entryPath: `/${path.relative(cwd, path.join(runtimeDir, 'app.js'))}`,
          },
        })
      );

      await fs.writeFile(path.join(runtimeDir, 'index.html'), indexHtml);
      await fs.writeFile(path.join(runtimeDir, 'app.js'), getEntryModule({ plugins }));

      /**
       * TODO: resolve the user config and merge it with ours...
       *
       * potentially "get" the config if it needs to be shared?
       *
       * What do we do about watch?
       */

      const entryChunkId = '.strapi/client/app.js';

      await viteBuildTask(ctx, {
        /**
         * We don't care about js vs jsx here.
         * And that's okay.
         */
        esbuild: {
          loader: 'jsx',
          include: /.*\.jsx?$/,
          exclude: [],
        },
        /**
         * We can remove `commonjs` when we bundle our own plugins
         * as we'll have CJS & ESM exports for everything...
         */
        plugins: [
          viteReact(),
          nodeResolve(),
          /**
           * TODO: can we get rid of this after we bundle our own plugins?
           */
          commonjs({
            exclude: [/node_modules/],
          }),
          {
            name: 'strapi/server/build-files',
            apply: 'build',
            buildStart() {
              this.emitFile({
                type: 'chunk',
                id: entryChunkId,
                name: 'strapi',
              });
            },
            async generateBundle(_options, outputBundle) {
              const bundle = outputBundle;
              const entryFile = Object.values(bundle).find(
                (file) =>
                  file.type === 'chunk' &&
                  file.name === 'strapi' &&
                  file.facadeModuleId?.endsWith(entryChunkId)
              );

              if (!entryFile) {
                throw new Error(`Failed to find entry file in bundle (${entryChunkId})`);
              }

              if (entryFile.type !== 'chunk') {
                throw new Error('Entry file is not a chunk');
              }

              const entryFileName = entryFile.fileName;
              const entryPath = ['/admin'.replace(/\/+$/, ''), entryFileName].join('/');

              console.log(entryPath);

              this.emitFile({
                type: 'asset',
                fileName: 'index.html',
                source: getDocumentHTML({
                  props: {
                    isVite: true,
                    entryPath,
                  },
                }),
              });
            },
          },
        ],
        resolve: {
          alias: {
            /**
             * TODO: this is a bit of a hack.
             * Don't normally have to do this, we should investigate why.
             * Is it because the example app is tied to our monorepo?
             */
            react: path.join(require.resolve('react'), '..'),
          },
        },
        mode: 'production',
        base: '/admin/',
        define: {
          /**
           * TODO: this needs to be created using the user's .env file.
           */
          'process.env': {
            ADMIN_PATH: '/admin/',
            NODE_ENV: 'development',
            STRAPI_ADMIN_BACKEND_URL: 'http://localhost:1337',
            STRAPI_TELEMETRY_DISABLED: 'true',
          },
        },
        build: {
          // minify: 'esbuild',
          copyPublicDir: false,
          assetsDir: '',
          rollupOptions: {
            input: {
              strapi: path.join(cwd, '.strapi', 'client', 'app.js'),
            },
          },
        },
      });
    } else if (builder === 'webpack') {
      /**
       * TODO: webpack backward compatibility.
       */
    }

    spinner.complete('@strapi/admin: Admin UI build successful');
  } catch (err) {
    spinner.error('@strapi/admin: Admin UI build failed');
    console.error(err);
    process.exit(1);
  }
};

/**
 * @typedef BuildContextOptions
 * @property {string} cwd
 * @property {string} distDir
 * @property {string} tsconfig
 */

/**
 * @typedef BuildContext
 * @property {string} cwd
 * @property {string} distDir
 * @property {string[]} external
 * @property {object} ts
 * @property {Pick<import('typescript').ParsedCommandLine, 'options'>} ts.config
 * @property {string} ts.configPath
 */

/**
 * @internal
 * @type {(options: BuildContextOptions) => Promise<BuildContext>}
 *
 * @description Create the build context to be used by either build pipeline.
 * @note If this became more generic to build
 * packages we could look at extending the context to expose more things like your export map etc.
 */
const createBuildContext = async ({ cwd, tsconfig: tsconfigPath, distDir }) => {
  const pkg = await loadPkg({ cwd });

  let tsconfig;

  if (tsconfigPath) {
    /**
     * @type {Omit<import('typescript').ParsedCommandLine, 'errors'>}
     */
    const { options } = await tsUtils.resolveConfigOptions(tsconfigPath);

    tsconfig = options;
  }

  /**
   * TODO: pass the target versions to the build pipeline for the admin panel meaning people
   * can support their own versions e.g. something dead if they wanted too?
   */
  // const targetVersions = resolveBrowserslistVersions(
  //   pkg.browserslist || DEFAULT_BROWSERSLIST_QUERY
  // );

  const parsedExternal = [
    ...(pkg.dependencies ? Object.keys(pkg.dependencies) : []),
    ...(pkg.peerDependencies ? Object.keys(pkg.peerDependencies) : []),
  ];

  const ctx = {
    cwd,
    distDir,
    external: parsedExternal,
    ts: {
      config: tsconfig,
      configPath: tsconfigPath,
    },
  };

  return ctx;
};

/**
 * @internal
 * @note could this be moved to somewhere global?
 * @type {(msg: string) => {complete: (msg?: string) => void; error: (msg?: string) => void}}
 */
const createSpinner = (msg) => {
  const startTime = Date.now();

  console.log(msg);

  return {
    complete(msg) {
      console.log(
        `${chalk.green('[success]')}${msg ? ` ${msg}` : ''} ${chalk.gray(
          `${Date.now() - startTime}ms`
        )}`
      );
    },
    error(msg) {
      console.log(
        `${chalk.red(`[error]`)}${msg ? ` ${msg}` : ''} ${chalk.gray(
          `${Date.now() - startTime}ms`
        )}`
      );
    },
  };
};

module.exports = buildAdmin;
